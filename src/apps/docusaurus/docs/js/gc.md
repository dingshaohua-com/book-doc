---
sidebar_position: 2
---

# 垃圾回收

Garbage Collection ，在有些语言中 是不支持垃圾自动回收比如C++，但目前大部分语言都支持 比如Java，Python，Go，Js。

程序运行需要被加载到内存中然后再被CPU执行，而程序在工作过程中 会产生很多垃圾，这些垃圾是程序**不用的内存**或者是之前**用过了以后不会再用的内存空间。**

这些不在占用内存的代码，将会被JS引擎内置的垃圾回收器，使用一些（确定是否垃圾的）策略自动将其回收，以释放内存空间。为了保证内存的占用 垃圾回收器还会定期执行。

## **垃圾回收策略-标记清除**

当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。

具体做法就说：垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了。

## **垃圾回收策略-引用计数**

引用计数算法的原理是设置一个引用数，判断当前引用数是否是0。

发生代码执行中，代码中有一个对象空间，多了一个变量名指向它，引用计数器就为它的引用数 + 1，减少一个引用引用计数器就为它的引用数 - 1， 一旦引用数变为 0， 该对象空间就会被认为是垃圾，然后被回收。

代码中，当我们执行完毕`fn`方法之后，就不能在访问到`num1`和`num2`了，
这就是因为它们的引用计数为0，被回收了。

```jsx
function fn() {
  const num1 = 1
  const num2 = 2
}

fn()
```

缺点：无法回收循环引用的对象。

```jsx
// 在函数执行结束后，虽然 obj1/2都无法被根访问到了，
// 但是由于他们自身互相引用所以根据引用计数法的回收条件，是无法被回收的。
function fn() {
    const obj1= {}
    const obj2= {}
    obj1.name = obj2
    obj2.name = obj1
fn()
```

## **内存泄露**

程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，就成了内存溢出。

1、全局变量挂载太多。

2、没有及时清理的计时器。

3、闭包

4、循环引用（在旧版浏览器下[使用的引用计数清理垃圾]）

## 内存溢出

当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误。

发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。如果这个快代码执行的多了，慢慢的就溢出了。

## 总结

正式因为**引用计数的**垃圾回收机制缺点明显，很容易造成无法正确判断垃圾的现象，造成内存泄漏，因此已经不被浏览器使用了。